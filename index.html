<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <link rel="stylesheet" type="text/css" href="stylesheets/chess.css" media="screen" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Chess by aganzha</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

	<header>
	  <h1>Chess</h1>
	  <h2>Small typescript framework</h2>
	</header>

	<section id="downloads" class="clearfix">
	  <a href="https://github.com/aganzha/chess/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
	  <a href="https://github.com/aganzha/chess/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
	  <a href="https://github.com/aganzha/chess" id="view-on-github" class="button"><span>View on GitHub</span></a>
	</section>

	<hr>

	<section id="main_content">
	  <h3>How Chess can help you</h3>

<p>
  Chess is a framework for creating single page javascript applications. This is NOT MVC framework.
  An idea behind Chess is declarative layout of reusable components. Chess is written in typescript
  and depends on Require.js and Zepto.js (or JQuery).
</p>

<p>Thats how layout declarations in Chess are look like:</p>
<pre>
  <code>
    var board = {
	  '<span class="blue">Title</span>':'This is a title',
	  '<span class="blue">Body</span>':{
	     '<span class="blue">LeftColumn</span>':{
	     }
	     '<span class="blue">RightColumn</span>':{
		 <span class="blue">'Button'</span>:'Click me'
	     }
	  '<span class="blue">Footer</span>':null
    }
  </code>
</pre>

<p>
  Nevermind how complex your app is, traversing html elements in firebug or webkit dev tools will be very easy, because html classes  generated will match exactly with appropriate declarations:
</p>
<pre>
  <code>
    &lt;div class="<span class="blue">Title</span>"&gt;This is a title&lt;/div&gt;
    &lt;div class="<span class="blue">Body</span>"&gt;
      &lt;div class="<span class="blue">LeftColumn</span>">&lt;/div&gt;
      &lt;div class="<span class="blue">RightColumn</span>">
	   &lt;div class="<span class="blue">Button</span>">Click me&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="<span class="blue">Footer</span>">&lt;/div&gt;
  </code>
</pre>
<p>Nevermind how complex your app is, changing styles for such an app is very easy. Especially when yo use SASS, cause your stylesheet rules could (Chess does not yet generate css) match exactly with appropriate declarations:</p>
<pre>
  <code>
    .<span class="blue">Title</span>{
	font-size:14px;
    }
    .<span class="blue">Body</span>{
	.<span class="blue">LeftColumn</span>{
	    foat:left;
	}
	.<span class="blue">RightColumn</span>{
	    foat:right;
    	    .<span class="blue">Button</span>{
	        cursor:pointer;
	    }
	}
    }
    .<span class="blue">Footer</span>{
	margin-top:20px;
    }
  </code>
</pre>

<p>
  And finally you can hook in any place of your application with your code just 
  providing class name used in your declarations:
</p>
<pre>
  <code>
    export class <span class="blue">Button</span> extends pieces.BaseCell{
	afterAppend(){
	    $(this.el).on('click', function(){
		  alert('It works')
	    })
	}
    }
  </code>
</pre>

<h3>Declaration Rules</h3>
<p>
  While declaring your components you can use next modificators:
  <pre class="leftCol">
    <code>
var board = {
    'Empty':<span class="bordo">null</span>,
    'Text':'<span class="bordo">Just a text</span>',
    'Html':'<span class="bordo">&lt;span&gt;HTML&lt;/span&gt;'</span>,

    'Unique<span class="bordo">#UID</span>':null,
    'Row<span class="bordo">.First</span>':null,
    'Row<span class="bordo">.Second.Last</span>':null,

    'Container':{
	'Child':{
	      'Level1':{
		  'Level2':null
	       }
	 },
	 '<span class="bordo" style="font-weight:bold;">_</span>Delayed':{
	       'Level1':{
		   '<span class="bordo" style="font-weight:bold;">_</span>Delayed2'null
	       }
	 }
    }
}
</code></pre>
  <pre class="rightCol">
    <code>

&lt;div class="Empty"&gt;&lt;/div&gt;
&lt;div class="Text"&gt;<span class="bordo">Just a text</span>&lt;/div&gt;
&lt;div class="Html"&gt;<span class="bordo">&lt;span&gt;HTML&lt;/span&gt;</span>&lt;/div&gt;

&lt;div <span class="bordo">class="Unique" id="UID"</span>&gt;&lt;/div&gt;
&lt;div <span class="bordo">class="Row First"</span>&gt;&lt;/div&gt;
&lt;div <span class="bordo">class="Row Second Last"</span>&gt;&lt;/div&gt;

&lt;div class="Container"&gt;
  &lt;div class="Child"&gt;
    &lt;div class="Level1"&gt;
      &lt;div class="Level2"&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

<a href="" class="blue">see using delayed</a>


    </code>
  </pre>
  <div style="clear:both"></div>
</p>

<h3>Application</h3> <!-- Components(Chess Pieces) -->
<p>
  For each component in your declaration, chess will look for class with the same name.
  It is ok to not provide class for each component. 
  When class could not be found Chess will create component from base classes.
  Most of the time you will create components just to render markup backed up by some css.  
  <ul>
    <li>
      All components are based on <strong>Cells</strong>(<span class="dark">pieces.BaseCell</span> 
      class).
    </li>
    <li>
      First level components in board (the board variable) are called <strong>Screens</strong> (<span class="dark">pieces.Screen</span> class)
      You can have several screens in your application 
      (separate screens for mobile app, modal forms etc).
    </li>
    <li>
      Main component to which your application is attached is called <strong>Viewport</strong>
      (<span class="dark">pieces.Viewport</span> class).
      You can have several application on page each attached to its viewport.
    </li>    
  </ul>
  
  To start application, you must instantiate it with the component declaration and 
  function which will choose screen for initial render.
  
  Here is the hello world:  
  <pre>
    <code>
      ///&lt;reference path="jquery.d.ts"/&gt;
      import chess = module("chess/app")
      import interfaces = module("chess/interfaces")
      import pieces = module("chess/pieces")
      
      var board = {
         'Screen':'Hello world'
      }

      var viewport = new pieces.ViewPort($('body')[0])
      var application = new chess.ChessApp(viewport,board, [])
      var selector = function(screens:interfaces.ScreenMap){
             var selected = screens['Screen']
             return selected
      }
      application.resolve(selector)
    </code>
  </pre>
  Third parameter in application constructor is a list of modules, from which application 
  will select classes declared in board. If no class will found, Chess 
  will take BaseCell for that component.
</p>

<h3>Chess Cell</h3>
<p>
  All your components must be inherited from pieces.BaseCell.
  Here are methods which could be overloaded:
  <pre>
    <code>
      export class MyButton extends pieces.BaseCell{

           <strong>// choose html tag another than div</strong>
           <span class="blue">createEl()</span>:HTMLElement{
              var el = document.createElement('span')
              // this.html attribute is taken from declaration
	      el.innerHTML = this.html
	      return el
          }

          <strong>// fill html attributes here</strong>
          <span class="blue">fillExtraAttrs()</span>{
              $(this.el).css('width', '100px');
          }

          <strong>// Put your business/gui logic in 3 below methods</strong>
          <span class="blue">afterResolve()</span>{
              // Component dom element is created, but it is not inserted into the 
	      // DOM tree.
	      // Element could have childnodes at this time but 
	      // nothing known about element parent.
          }
          <span class="blue">afterAppend()</span>{
	     // This is most usefull method.
	     // Component dom element is created, but it is not inserted into the 
	     // DOM tree.
	     // Element could have childnodes and parent node.
	     // This is the best place to put your event handlers code such as 
	     // $(this.el).on('click', ...
          }
          <span class="blue">afterRender()</span>{
	     // All DOM tree is ready now. You can put here code which require
	     // measurements sach as offsetWidth etc.
          }
      }
    </code>
  </pre>
 
</p>



<h3>Support or Contact</h3>

	  <p>aganzha@yandex.ru</p>

	<footer>
	  Chess is maintained by <a href="https://github.com/aganzha">aganzha</a><br>
	  This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="http://twitter.com/jasonlong">Jason Long</a>.
	</footer>


      </div>
    </div>
  </body>
</html>
