<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <link rel="stylesheet" type="text/css" href="stylesheets/chess.css" media="screen" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Chess by aganzha</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

	<header>
	  <h1>Chess</h1>
	  <h2>Small typescript framework</h2>
	</header>

	<section id="downloads" class="clearfix">
	  <a href="https://github.com/aganzha/chess/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
	  <a href="https://github.com/aganzha/chess/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
	  <a href="https://github.com/aganzha/chess" id="view-on-github" class="button"><span>View on GitHub</span></a>
	</section>

	<hr>

	<section id="main_content">
	  <h3>How Chess can help you</h3>

<p>
  Chess is a layout framework for javascript applications.
  This is NOT MVC framework.
  An idea behind Chess is declarative layout of reusable components. Chess is written in typescript
  and depends on Require.js and Zepto.js (or JQuery).
</p>

<p>Thats how layout declarations in Chess are look like:</p>
<pre>
  <code>
    var board = {
	  '<span class="blue">Title</span>':'This is a title',
	  '<span class="blue">Body</span>':{
	     '<span class="blue">LeftColumn</span>':{
	     }
	     '<span class="blue">RightColumn</span>':{
		 <span class="blue">'Button'</span>:'Click me'
	     }
	  '<span class="blue">Footer</span>':null
    }
  </code>
</pre>

<p>
  Nevermind how complex your app is, traversing html elements in firebug or webkit dev tools will be very easy, because html classes  generated will match exactly with appropriate declarations:
</p>
<pre>
  <code>
    &lt;div class="<span class="blue">Title</span>"&gt;This is a title&lt;/div&gt;
    &lt;div class="<span class="blue">Body</span>"&gt;
      &lt;div class="<span class="blue">LeftColumn</span>">&lt;/div&gt;
      &lt;div class="<span class="blue">RightColumn</span>">
	   &lt;div class="<span class="blue">Button</span>">Click me&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="<span class="blue">Footer</span>">&lt;/div&gt;
  </code>
</pre>
<p>Nevermind how complex your app is, changing styles for such an app is very easy. Especially when yo use SASS, cause your stylesheet rules could (Chess does not yet generate css) match exactly with appropriate declarations:</p>
<pre>
  <code>
    .<span class="blue">Title</span>{
	font-size:14px;
    }
    .<span class="blue">Body</span>{
	.<span class="blue">LeftColumn</span>{
	    foat:left;
	}
	.<span class="blue">RightColumn</span>{
	    foat:right;
    	    .<span class="blue">Button</span>{
		cursor:pointer;
	    }
	}
    }
    .<span class="blue">Footer</span>{
	margin-top:20px;
    }
  </code>
</pre>

<p>
  And finally you can hook in any place of your application with your code just
  providing class name used in your declarations:
</p>
<pre>
  <code>
    export class <span class="blue">Button</span> extends pieces.BaseCell{
	afterAppend(){
	    $(this.el).on('click', function(){
		  alert('It works')
	    })
	}
    }
  </code>
</pre>

<h3>Declaration Rules</h3>
<p>
  While declaring your components you can use next modificators:
  <pre class="leftCol">
    <code>
var board = {
    'Empty':<span class="bordo">null</span>,
    'Text':'<span class="bordo">Just a text</span>',
    'Html':'<span class="bordo">&lt;span&gt;HTML&lt;/span&gt;'</span>,

    'Unique<span class="bordo">#UID</span>':null,
    'Row<span class="bordo">.First</span>':null,
    'Row<span class="bordo">.Second.Last</span>':null,

    'Container':{
	'Child':{
	      'Level1':{
		  'Level2':null
	       }
	 },
	 '<span class="bordo" style="font-weight:bold;">_</span>Delayed':{
	       'Level1':{
		   '<span class="bordo" style="font-weight:bold;">_</span>Delayed2'null
	       }
	 }
    }
}
</code></pre>
  <pre class="rightCol">
    <code>

&lt;div class="Empty"&gt;&lt;/div&gt;
&lt;div class="Text"&gt;<span class="bordo">Just a text</span>&lt;/div&gt;
&lt;div class="Html"&gt;<span class="bordo">&lt;span&gt;HTML&lt;/span&gt;</span>&lt;/div&gt;

&lt;div <span class="bordo">class="Unique" id="UID"</span>&gt;&lt;/div&gt;
&lt;div <span class="bordo">class="Row First"</span>&gt;&lt;/div&gt;
&lt;div <span class="bordo">class="Row Second Last"</span>&gt;&lt;/div&gt;

&lt;div class="Container"&gt;
  &lt;div class="Child"&gt;
    &lt;div class="Level1"&gt;
      &lt;div class="Level2"&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

<a href="" class="blue">see using delayed</a>


    </code>
  </pre>
  <div style="clear:both"></div>
</p>

<h3>Application</h3> <!-- Components(Chess Pieces) -->
<p>
  For each component in your declaration, chess will look for class with the same name.
  It is ok to not provide class for each component.
  When class could not be found Chess will create component from base classes.
  Most of the time you will create components just to render markup backed up by some css.
  <ul>
    <li>
      All components are based on <strong>Cells</strong>(<span class="dark">pieces.BaseCell</span>
      class).
    </li>
    <li>
      First level components in board (the board variable) are called <strong>Screens</strong> (<span class="dark">pieces.Screen</span> class)
      You can have several screens in your application
      (separate screens for mobile app, modal forms etc).
    </li>
    <li>
      Main component to which your application is attached is called <strong>Viewport</strong>
      (<span class="dark">pieces.Viewport</span> class).
      You can have several application on page each attached to its viewport.
    </li>
  </ul>

  To start application, you must instantiate it with the component declaration and
  function which will choose screen for initial render.

  Here is the hello world:
  <pre>
    <code>
      ///&lt;reference path="jquery.d.ts"/&gt;
      import chess = module("chess/app")
      import interfaces = module("chess/interfaces")
      import pieces = module("chess/pieces")

      var board = {
	 'Screen':'Hello world'
      }

      var viewport = new pieces.ViewPort($('body')[0])
      var application = new chess.ChessApp(viewport,board, [])
      var selector = function(screens:interfaces.ScreenMap){
	     var selected = screens['Screen']
	     return selected
      }
      application.resolve(selector)
    </code>
  </pre>
  Third parameter in application constructor is a list of modules, from which application
  will select classes declared in board. If no class will found, Chess
  will take BaseCell for that component.
</p>

<h3>Chess Cell</h3>
<p>
  All your components must be inherited from pieces.BaseCell.
  Here are methods which could be overloaded:
  <pre>
    <code>
      export class MyButton extends pieces.BaseCell{

	   <strong>// choose html tag another than div</strong>
	   <span class="blue">createEl()</span>:HTMLElement{
	      var el = document.createElement('span')
	      // this.html attribute is taken from declaration
	      el.innerHTML = this.html
	      return el
	  }

	  <strong>// fill html attributes here</strong>
	  <span class="blue">fillExtraAttrs()</span>{
	      $(this.el).css('width', '100px');
	  }

	  <strong>// Put your business/gui logic in 3 below methods</strong>
	  <span class="blue">afterResolve()</span>{
	      // Component dom element is created, but it is not inserted into the
	      // DOM tree.
	      // Element could have childnodes at this time but
	      // nothing known about element parent.
	  }
	  <span class="blue">afterAppend()</span>{
	     // This is most usefull method.
	     // Component dom element is created, but it is not inserted into the
	     // DOM tree.
	     // Element could have childnodes and parent node.
	     // This is the best place to put your event handlers code such as
	     // $(this.el).on('click', ...
	  }
	  <span class="blue">afterRender()</span>{
	     // All DOM tree is ready now. You can put here code which require
	     // measurements sach as offsetWidth etc.
	  }
      }
    </code>
  </pre>
</p>
<p>
  Here some attributes and methods of cells which you will use quite often
  (from chess/interfaces.ts):
  <pre>
    <code>
      export <strong>interface Cell</strong>{
	    // applicatin reference
	    <span class="blue">application</span>:Application;
	    // parent cell
	    <span class="blue">parent</span>:Cell;
	    // array of child cells
	    <span class="blue">children</span>:Cell[];
	    // DOM element of the cell
	    <span class="blue">el</span>:HTMLElement;

	    // cell record in layout
	    <span class="blue">record</span>:{cons:string;classes:string[];id:string;};

	    // method for search children
	    <span class="blue">query</span>(cons?:string, className?:string,id?:string):Cell[];
	    // same as above but return first found child
	    <span class="blue">find</span>(cons?:string, className?:string,id?:string):Cell;
      }
    </code>
  </pre>
  <strong>Cons</strong> in cell record and <strong>cons</strong> parameter in find 
  and query is a component key in layout declaration before any dot
  or hash. For example in <em>var board = { 'Main.SomeClass' = null }</em> cons is the string 'Main'.
</p>

<h3>Delayed Cell</h3>
<p>
  To declare components which are not available at startup time use <strong>Delayed Cells</strong>
  <pre class="leftCol">
    <code>
      var board = {
          'List':{
               '<span class="blue">_</span>ListItem':{
                   'Title':null,
                   'Body':null,
                   'Button':'Click me'   
               }
           }
      }
    </code>
  </pre>
  <pre class="rightCol">
    <code>
      &lt;div class="List"&gt;&lt;/div&gt;








    </code>
  </pre>
  An underscore before component name means that component will be created, but not renderred
  to the DOM tree. You choose when and how many times to render it.
  <pre>
    <code>
var list = application.viewport.find('List')

$.ajax({
    url:'/your_datasource',
    success:function(data:IYourObject[]){
	for(var i =0,l=data.length;i&lt;l;i++){
	    list.<span class="blue">forceDelayed</span>(function(<span class="blue">cell</span>:interfaces.Cell){
		switch(cell.record.cons){
		    case ('ListItem'):
			//next cell
			break
		    case ('Title'):
			// fill title
			cell.updateEl(data[i].title)
			break
		    case ('Body'):
			// fill body
			cell.updateEl(data[i].body)
			break
		}
	    })
    </code>
  </pre>
  Each cell has <strong>forceDelayed</strong> method which receives as an argument a function
  which will be called with each cell in the delayed declaration. The example above will render
  next markup for the output from '/your_datasource' <br/>[{"title":"<span class="dark">Item1</span>","body":"<span class="dark">this is first item</span>"},{"title":"<span class="dark">Item2</span>","body":"<span class="dark">this is second item</span>"}] :
  <pre>
    <code>
      &lt;div class="List"&gt;
	&lt;div class="ListItem"&gt;
	  &lt;div class="<span class="bordo">Title</span>"<span class="blue">Item1</span>&gt;&lt;/div&gt;
	  &lt;div class="<span class="bordo">Body</span>"&gt;<span class="blue">This is first item</span>&lt;/div&gt;
	  &lt;div class="Button"&gt;Click me&lt;/div&gt;
	&lt;/div&gt;
	&lt;div class="ListItem"&gt;
	  &lt;div class="<span class="bordo">Title</span>"&gt;<span class="blue">Item2</span>&lt;/div&gt;
	  &lt;div class="<span class="bordo">Body</span>"&gt;<span class="blue">This is second item</span>&lt;/div&gt;
	  &lt;div class="Button"&gt;Click me&lt;/div&gt;
	&lt;/div&gt;
      &lt;/div&gt;

    </code>    
  </pre>
</p>


<h3>Support or Contact</h3>

	  <p>aganzha@yandex.ru</p>

	<footer>
	  Chess is maintained by <a href="https://github.com/aganzha">aganzha</a><br>
	  This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="http://twitter.com/jasonlong">Jason Long</a>.
	</footer>


      </div>
    </div>
  </body>
</html>
